---
globs: packages/backend/convex/**/*.ts
---

# Convex Backend Rules

Apply these rules when working in `packages/backend/convex/`.

## File Organization

- One domain per file (e.g., `collections.ts`, `searchRequests.ts`)
- Export multiple related functions from the same file
- Use `_generated/` for auto-generated types (never edit)

## Function Syntax (REQUIRED)

**Always use the new function syntax** with explicit args and returns:

```typescript
import { query, mutation, action } from "./_generated/server";
import { v } from "convex/values";

export const myQuery = query({
  args: { id: v.id("collections") },
  returns: v.string(),
  handler: async (ctx, args) => {
    // implementation
  },
});
```

### Function Types

- `query` - Read data, reactive, public
- `mutation` - Write data, public
- `action` - Node.js runtime, external APIs, public
- `internalQuery`, `internalMutation`, `internalAction` - Private versions

**Important**: Always include `returns:` validator. Use `v.null()` if no return value.

## Validators

Use `v` from `convex/values` for all validation:

```typescript
// Primitives
v.string();
v.number();
v.boolean();
v.null();
v.int64();
v.bytes();

// Complex
v.id("tableName");
v.array(v.string());
v.object({ key: v.string() });
v.union(v.literal("a"), v.literal("b"));
v.optional(v.string());
v.record(v.string(), v.number());
```

## Calling Functions

```typescript
import { api, internal } from "./_generated/api";

// In queries
await ctx.runQuery(api.collections.get, { id });

// In mutations
await ctx.runMutation(internal.collections.updateStatus, { id, status });

// In actions
await ctx.runAction(api.someAction.process, {});
```

**Never** call functions directly - always use `ctx.runQuery/runMutation/runAction` with function references.

## Database Operations

### Queries

```typescript
// With index (preferred)
await ctx.db
  .query("collections")
  .withIndex("by_subdomain", (q) => q.eq("subdomain", subdomain))
  .first();

// Order
await ctx.db.query("collections").order("desc").collect();

// Get by ID
await ctx.db.get(id);
```

**Never use `.filter()`** - always define and use indexes.

### Mutations

```typescript
// Insert
const id = await ctx.db.insert("collections", { title, status });

// Update (partial)
await ctx.db.patch(id, { status: "complete" });

// Replace (full)
await ctx.db.replace(id, { ...fullObject });

// Delete
await ctx.db.delete(id);
```

## Schema Definition

Define in `schema.ts`:

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  collections: defineTable({
    subdomain: v.string(),
    status: v.union(
      v.literal("not_started"),
      v.literal("processing"),
      v.literal("complete"),
      v.literal("error")
    ),
    imagesCount: v.number(),
  })
    .index("by_subdomain", ["subdomain"])
    .index("by_status", ["status"]),
});
```

**Index naming**: Include all fields in name (e.g., `by_field1_and_field2`).

## TypeScript Types

```typescript
import { Doc, Id } from "./_generated/dataModel";

// Document type
type Collection = Doc<"collections">;

// ID type
const id: Id<"collections"> = "...";

// Be strict with ID types - use Id<"tableName">, not string
```

## Return Type Patterns

### Nullable document

```typescript
returns: v.union(
  v.object({
    _id: v.id("collections"),
    _creationTime: v.number(),
    // ... other fields
  }),
  v.null()
);
```

### Array of documents

```typescript
returns: v.array(
  v.object({
    _id: v.id("collections"),
    // ... fields
  })
);
```

## Actions with Node.js APIs

```typescript
"use node"; // Add at top of file

import { action } from "./_generated/server";

export const callExternalAPI = action({
  args: {},
  returns: v.null(),
  handler: async (ctx, args) => {
    const response = await fetch("https://api.example.com");
    // Process response
    return null;
  },
});
```

## Common Patterns in This Project

### Status tracking

```typescript
status: v.union(
  v.literal("not_started"),
  v.literal("processing"),
  v.literal("complete"),
  v.literal("error")
);
```

### Progress updates

```typescript
export const updateProgress = mutation({
  args: {
    id: v.id("searchRequests"),
    processedImages: v.number(),
    totalImages: v.number(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.patch(args.id, {
      processedImages: args.processedImages,
      totalImages: args.totalImages,
    });
    return null;
  },
});
```

## Error Handling

```typescript
export const myMutation = mutation({
  args: { id: v.id("collections") },
  returns: v.null(),
  handler: async (ctx, args) => {
    const doc = await ctx.db.get(args.id);
    if (!doc) {
      throw new Error("Collection not found");
    }
    // proceed
    return null;
  },
});
```

Convex automatically serializes thrown errors to clients.

## Logging

Add detailed logs for debugging:

```typescript
console.log("Creating collection:", { title, subdomain, status });
console.log("Search request updated:", { requestId, status, progress });
```

## Reference

See [docs/convex_rules.md](mdc:docs/convex_rules.md) for complete Convex guidelines.
